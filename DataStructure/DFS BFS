
来自《leetcode-cpp》白熊求职第9章和10章小结.非常好。

广度搜索和深度搜索的代码实现其实是一样的，只是存储用的数据结构不同，广搜用queue, 深搜用stack;

广搜适用场景：
输入数据：没什么特征，不像深搜，需要有“递归”的性质。如果是树或者图，概率更大。
状态转换图：树或者图。
求解目标：求最短。

思考的步骤
1. 是求路径长度，还是路径本身（或动作序列）？
(a) 如果是求路径长度，则状态里面要存路径长度（或双队列+ 一个全局变量step）
(b) 如果是求路径本身或动作序列:
    i. 要用一棵树存储宽搜过程中的路径
    ii. 是否可以预估状态个数的上限？能够预估状态总数，则开一个大数组，用树的双亲表示法；如果不能预估状态总数，则要使用一棵通用的树。这一步也是第4步的必要不充分条件。

2. 如何表示状态？即一个状态需要存储哪些些必要的数据，才能够完整提供如何扩展到下一步状态的所有信息。一般记录当前位置或整体局面。

3. 如何扩展状态？这一步跟第2 步相关。状态里记录的数据不同，扩展方法就不同。对于固定不变的数据结构（一般题目直接给出，作为输入数据），如二叉树，图等，扩展方法很简单
直接往下一层走，对于隐式图，要先在第1 步里想清楚状态所带的数据，想清楚了这点，那如何扩展就很简单了。

4. 关于判重，状态是否存在完美哈希方案能够将状态一一映射到整数，互相之间不会冲突。
(a) 如果不存在，则需要使用通用的哈希表（例如unordered_set）来判重；
(b) 如果存在，则可以开一个大布尔数组，作为哈希表来判重，且此时可以精确计算出状态总数，而不仅仅是预估上限。

5. 目标状态是否已知？如果题目已经给出了目标状态，可以带来很大便利，这时候可以从起始状态出发，正向广搜； 也可以从目标状态出发，逆向广搜；也可以同时出发，双向广搜。



代码实现：

广搜需要一个队列queue，用于一层一层扩展，一个hashset，用于判重， 对于队列，可以用queue，当求长度时，有两种做法：
     1. 只用一个队列，但在状态结构体state_t里增加一个整数字段step，表示走到当前状态用 了多少步，当碰到目标状态，直接输出step即可。这个方案，可以很方便的变成A* 算法，把队列换成priority_queue优先队列即可。
     2. 用两个队列，current,next，分别表示当前层次和下一层，交替访问，另设一个全局整数level，表 示层数（也即路径长度），当碰到目标状态，输出level即可。这个方案，状态可以少一个字段，节省内存。
     对于hashset可以用STL 里的set或unordered_set ;
     对于树，如果用STL，可以用unordered_map<state_t,state_t> father表示一颗树，代码非 常简洁。

vector<state_t> bfs(const state_t& start, const vector<vector<int>>& grid)
{
  queue<state_t> q;
  unordered_set<state_t> visited;
  unorderd_map<state_t,state_t>father;
  int level = 0;
  bool found = false;
  auto reachTarget = [this](const state_t& s){return s == this->t;}
  auto state_extend = [](const state_t& cur){ 
    vector<state_t> childs;
    if(!visited(x)) childs.push(x); visited[x] = true;
    return childs;
  }
  q.push(start);
  while(!q.empty() && !found)
  {
    const state_t state = q.front();q.pop();
    vector<state_t> new_States = state_extend(state);
    for(auto iter = new_states.cbegin();iter != new_states.cend() && !found; ++iter)
    {
      if(reachTarget(*iter))
      {
        father[new_state] = state;
        return found = true;
      }
      q.push(*iter);
      father[new_state] = state;
    }
  }
  if(found) return gen_path(father, target);
  else return vector<state_t>();
}


////////////////////////////////////////////////////深度搜索总结

10.12.1 深度搜索适用场景
输入数据：如果是递归数据结构，如单链表，二叉树，集合，则百分之百可以用深搜；如果是非递归数据结构，如一维数组，二维数组，字符串，图，则概率小一些。
状态转换图：树或者图。
求解目标：必须要走到最深（例如对于树，必须要走到叶子节点）才能得到一个解，这种情况适合用深搜。

10.12.2 思考的步骤
1. 是求路径条数，还是路径本身（或动作序列）？深搜最常见的三个问题，求可行解的总数，求一个可行解，求所有可行解。

(a) 如果是路径条数，则不需要存储路径。
(b) 如果是求路径本身，则要用一个数组path[] 存储路径。跟宽搜不同，宽搜虽然最终求的也是一条路径，但是需要存储扩展过程中的所有路径，在没找到答案之前所有路径都不能放弃；而深搜，在搜索过程中始终只有一条路径，因此用一个数组就足够了(save/revert)。

2. 只要求一个解，还是要求所有解？如果只要求一个解，那找到一个就可以返回；如果要求所有解，找到了一个后，还要继续扩展，直到遍历完。广搜一般只要求一个解，因而不需要考虑这个问题（广搜当然也可以求所有解，这时需要扩展到所有叶子节点，相当于在内存中存储整个状态转换图，非常占内存，因此广搜不适合解这类问题）。

3. 如何表示状态？即一个状态需要存储哪些些必要的数据，才能够完整提供如何扩展到下一步状态的所有信息。广搜是把数据记录在状态struct里，而深搜的惯用写法是作为函数参数（有时为了节省递归堆栈，用全局变量），struct里的字段与函数参数一一对应。

4. 如何扩展状态？这一步跟上一步相关。状态里记录的数据不同，扩展方法就不同。对于固定不变的数据结构（一般题目直接给出，作为输入数据），如二叉树，图等，扩展方法很简单，直接往下一层走，对于隐式图，要先在第1 步里想清楚状态所带的数据，想清楚了这点，那如何扩展就很简单了。

5. 关于判重
(a) 是否需要判重？如果状态转换图是一棵树，则不需要判重，因为在遍历过程中不可能重复；如果状态转换图是一个DAG，则需要判重。如果把握不准，最好判重。
(b) 怎样判重？跟广搜相同，见第§9.4 节。同时，DAG 说明存在重叠子问题，此时可以用缓存加速，见第8 步。

6. 终止条件是什么？终止条件是指到了不能扩展的末端节点。对于树，是叶子节点，对于图或隐式图，是出度为0 的节点。

7. 收敛条件是什么？收敛条件是指找到了一个合法解的时刻。如果是正向深搜（父状态处理完了才进行递归，即父状态不依赖子状态，递归语句一定是在最后，尾递归），则是指是否达到
目标状态；如果是逆向深搜（处理父状态时需要先知道子状态的结果，此时递归语句不在最后），则是指是否到达初始状态。由于很多时候终止条件和收敛条件是是合二为一的，因此很多人不区分这两种条件。仔细区分这两种条件，还是很有必要的。
为了判断是否到了收敛条件，要在函数接口里用一个参数记录当前的位置（或距离目标还有多远）。如果是求一个解，直接返回这个解；如果是求所有解，要在这里收集解，即把路径复制到解集合里。

8.如何加速
(a) 剪枝。深搜一定要好好考虑怎么剪枝，成本小收益大，加几行代码，就能大大加速。这里没有通用方法，只能具体问题具体分析，要充分观察，充分利用各种信息来剪枝，在中间节点提前返回。

(b) 缓存。
i. 前提条件：状态转换图是一个DAG。DAG=> 存在重叠子问题=> 子问题的解会被重复利用，用缓存自然会有加速效果。如果依赖关系是树状的（例如树，单链表等），没必要加缓存，因为子问题只会一层层往下，用一次就再也不会用到，加了缓存也没什么加速效果。

ii. 具体实现：可以用数组或HashMap。维度简单的，用数组；维度复杂的，用HashMap，C++ 有map，C++ 11 以后有unorderedmap, 比map快.

拿到一个题目，当感觉它适合用深搜解决时，在心里面把上面8 个问题默默回答一遍，代码基本上就能写出来了。对于树，不需要回答第5 和第8 个问题。
如果读者对上面的经验总结看不懂或 感觉“不实用”，很正常，因为这些经验总结是我做了很多题目后总结出来的，
从思维的发展过程看，“经验总结”要晚于感性认识，所以这时候建议读者先做做前面的题目，积累一定的感性认识后，再回过头来看这一节的总结，一定会有共鸣。

深搜一般用递归实现，这样比较简洁。深搜比穷举法要快因为可以剪枝。

深搜和递归的区别： 递归一定是深搜，而深搜可以不用递归实现，比如用栈。

void dfs(type&input, type&path, gap)
{
  if(invalid(input)) return;
  if(isLeaf(gap))
  {
    result.push(path);return;
  }
  if(couldCut(x)) return;
  for(extend_state(curr))
  {
    changePath();
    if(dfs(input,path,gap--) == ok) return;
    revertPath();
  }
}
